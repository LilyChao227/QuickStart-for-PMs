> 一个人在热气球上飞行，意识到自己迷路了。突然，他发现下面有一个人，于是，他朝那个人大声喊道：\n
> “对不起，你能帮帮我吗？我答应我的朋友半个小时前和他见面，但我却迷路了，不知道自己在哪里。”\n
> 下面的人回答道：“你在一个热气球里，大约在 30 英尺处盘旋。你的位置在北纬 40 度到 42 度之间，西经 58 到 60 度之间。”\n
> “你一定是个程序员”，热气球上的人说。\n
> “我是”，地上的人回答。“你是怎么知道的？”\n
> “嗯”，气球上的人说，“你告诉我的一切在技术上都是正确的，但我仍然不知道自己在哪里。”\n
> 地上的人说：“你一定是个产品经理”。\n
> “我是，”气球上的人回答，“但你怎么知道的？”\n
> “嗯，你不知道你在哪里，也不知道你要去哪里。你向你的朋友许下了一个你无法兑现的承诺，然后你却希望我来解决你的问题。”地上的人说，\n
> “事实上，你的处境和我们见面之前一模一样，但不知为何，现在却好像一切都是我的错。”
# 1. 基本概念
“互联网行业”或“互联网公司”们，在经历了十数年的疯狂扩张之后，他们引以为傲的增长神话似乎已经开始崩解。我们现在应该承认，“互联网”正在向一个空无一物的概念神教演化。如果揭开这种为了概念而概念的面纱，我们就会发现，互联网公司本质上是软件公司，不论再怎样包装（产品？生态？），软件开发就是软件开发。软件是一个系统工程，是工程就有分工，就有流程和规范。产品经理干的活就是工程里的设计师，要做什么、怎么做，把这些事情给工程师（研发）讲明白，才能把工程建完。
既然是一个工程，就必须要有流程和规范，不然工程就乱套了。本节介绍一些基本的流程和规范，这些内容在工作中一定会用到。
## 1.1. 认识团队和同事
人是工程的基本组成部分，没有人就没有工程。因此，在开始你的工作之前，先认识你的团队和同事。**工程以人为本**，人和人的互动往往比遵守规则和流程更重要。合作良好的团队创造软件，合作失败的团队创造垃圾。
- **产品经理**：product manager，意为产品管理人。顾名思义，PM需要对某个产品负责。在互联网行业，产品大多数时候指的都是软件。PM需要对软件负责，负责设计它的样子、运行的逻辑、达成的目标，PM的工作职责就是不断地完善软件，通过软件解决用户的问题或者帮助用户完成他们的目标。但是PM一般不直接编码，而是进行产品设计，就像上述所说，PM是工程里的设计师，负责整体的设计和方案的撰写，编码是研发的工作，研发面临更加复杂的细节逻辑。PM的交付物是方案文档。
- **研发**：Research & Develop，意为研究与开发，缩写为RD。顾名思义，RD需要对PM提交的设计的相关内容进行研究，输出软件开发方面的专业建议，完善设计的细节，最终转化为代码，交付物为可工作的软件。现如今除了一些特殊的项目之外，RD一般不在本地开发软件，分布式开发已成常态。RD大致可分为以下几种。
  - **前端工程师**。Front-End，FE。前端主要负责用户交互界面的开发，常见的前端技术栈有：HTML，CSS，JavaScript等语言，React，Vue等框架，跨平台开发可能用到React Native，Flutter，Electron等。前端和UI/UE的工作合作紧密，在大部分注重交互界面的需求中，前端需要根据UI/UE的设计稿开发软件的界面、交互和视觉的效果等，保证用户界面符合PM的设计原则和UI/UE的设计效果。例如团队需要实现一个订单处理系统，前端可能需要负责整个界面的交互开发：用户在哪里创建新的订单，填写的表格长什么样，表格长度超过屏幕时的滚动效果怎样等等。前端一般不直接处理数据和具体的业务逻辑，但是实际开发过程中也需要根据实际情况划分前后端的开发范围。
  - **后端工程师**。Back-End，BE。后端主要负责处理数据和业务逻辑，他们专注于业务逻辑的实现，常见的后端技术栈有：C，C++，C#，Python，Java，Go等编程语言，MySQL，PostgreSQL等数据库工具，Docker，k8s等容器化工具等等。后端工程关注细节的业务逻辑，如果需要实现一个订单处理系统，后端可能需要负责整个订单的流程：用户填写完订单之后如何记录和存储，商品交付时需要修改订单的状态，在交付过程中客户可能修改订单的一些内容，哪些可以修改，哪些不可以修改，如何查找订单等等。接口是前后端之间的桥梁，接口会提供通过JSON、XML等格式封装好的数据包，前后端根据约定好的接口请求和返回规范完成数据的交换。
  - **全栈工程师**。Full Stack，全栈有两种含义，一种是指同一个开发者同时掌握前后端的技术栈，能够在项目开发过程中，根据具体情况，灵活切换前端或后端两种角色；另一种是指同一个开发者或团队同时开发同一个需求或项目的前后端工作。
  - **TL**.Tech Lead，技术代表。TL一般不是一个独立的职位，它通常只是研发团队中的某个人的角色标签，这个人可能负责本项目时间较长、经验更足，也有可能在相关业务方向有更多的了解和经验，或者也有可能是研发团队的直属领导。TL一般会主导项目的技术选型、架构设计，结合PM对各项需求的优先级排序，统筹团队的人力资源安排等。TL对整个迭代过程中研发团队的工作和进度负责。PM在梳理需求和方案时，一般都需要注重和TL之间的交流，TL的意见能够代表研发团队对业务的总体认知、对各项需求的技术难度预估等。一个需求是否可行、应采取什么样的方案、在当前的项目状态下不同的方案会带来什么后果等等，都是PM应当经常与TL讨论的问题。一般来说团队不会明确告诉PM谁是TL。
- **测试**：Quality Assurance，QA。QA的工作旨在保证产品的质量，以确保研发交付的结果满足产品的设计要求和用户的使用需求，尽量发现未被PM发现的边界逻辑问题、未被RD设计所规避的细节bug等等。在RD提交他们的代码之后，QA会首先介入进行代码测试，以保证上线之后的产品效果符合上述标准，只有测试无误之后，才会允许新的代码发布上线。测试人员发现的问题，根据问题的类型，有可能反馈给RD，也有可能反馈给PM。代码和逻辑缺陷一般直接由RD修改，如果QA和RD认为某个问题是需求不明确引起的，他们也会向PM提出，需要PM确认是否修改。
- **用户界面/体验设计师**：User Interface / User Experience。严格来说这是两个不同的职位，UI偏向于界面设计，例如按钮和列表的样式、字体和颜色的组合、动效的设计等；UE偏向于体验设计，例如不同按钮之间如何排列、不同层级的界面按照什么顺序来展示等。现如今也有很多公司不那么严格的区分UI和UE，统一以UX的职位管理。一般来说，如果你的需求涉及到用户交互与体验的改版、升级、修改，尤其是改动较多、较大时，FE就需要依赖UX的高保真设计图进行开发，因为PM常常难以考虑到用户界面与体验的各方面细节，或者公司对产品界面、交互风格有统一规定时，PM也很难做到如此精细的设计。设计工具的进步很快，目前UX常用的工具有Figma等，它们能帮助UX在线同步设计，非常方便快捷，也有丰富的社区内容。
- **产品运营**：产品运营负责运营当前的产品，也就是软件。这里的运营包含很多工作，例如把产品推荐给潜在用户、宣传、使用指导、问题收集和反馈等等。产品运营一般对产品的推广和反馈负责，也在很大程度上直接接触用户的问题、诉求、诘问甚至辱骂，他们是产品得以逐步升级优化的关键角色。
## 1.2. 迭代与迭代中的工作
迭代（sprint），是一个敏捷（scrum）的概念。但是我们不用管它，因为在这里没有真正的敏捷（当然，“真正的敏捷”这个概念似乎也不太符合[敏捷宣言](https://agilemanifesto.org/iso/zhchs/manifesto.html)的期待）。
你可以认为迭代是一整个完整项目中的最小任务周期。一个工程不可能一夜之间从无到有，我们必须拆解任务，迭代就是完成一项一项任务的周期。
在这里，迭代就是一个完整的工作周期，往往是两周，但不一定是从周一开始。在这个周期开始之前或初期，我们要准备好需求方案，给研发和测试讲清楚要做什么，然后他们根据你的设计和期望，做出技术方案设计，在周期中剩下的时间内完成你的设计。一个典型的迭代由以下几个环节组成：
![迭代流程示意图](sources/sprint_flow.jpg)
1. **需求方案撰写**：不一定在迭代内完成，它往往提前于迭代准备好，**这可能是你工作中最重要的一部分**。你要在方案中尽可能完善你的设计，发现并解决所有隐藏的风险和逻辑漏洞，并且用研发能够理解的语言（或者原型图、流程图、伪代码、真代码等等任何工具）描述清楚。
2. **需求评审**：你召集研发和测试，给他们讲解你的方案，在此过程中你们通过沟通、提问、解答来澄清方案中任何可能不清楚的细节。对于你无法解释或者暂未考虑到的细节问题，你需要记下来，在后续的几天中完善、调整甚至重做你的设计，召集二次评审会议阐释你的设计。需求评审的最理想状态是参会的每个人（包括你），都完全理解需求的目的和理想结果，以及自己在这中间的具体职责。
3. **技术详设**：研发召集你和测试，展示他们的技术设计方案。详设方案可能包含很多内容，例如业务逻辑实现的细节、接口的定义、数据的分层、任务的执行顺序和重试机制等等等等——总而言之，就是研发们为了实现你的需求，给自己规划了哪些具体工作。在这个会议上你可能有很多听不懂的地方，但是这不重要，你在这个会上的角色是顾问。研发也许会针对他们方案中的细节咨询你，以确认他们的设计确实能够实现你的需求。在某些简单的需求中，这个环节可能被省略。一般来说，技术详设之后，研发们会预估本次需求的排期，也就是按照他们的方案，这项需求预计在什么时候完成。
排期很重要，如果你的需求有原始需求方，及时和他们同步这一信息；如果它不符合你或需求方的预期，一定要尝试争取更多资源推动它往前。
4. **开发**：研发们会按照他们设计的方案进行开发，在此过程中，他们可能随时调整方案内容。与他们保持信息共享非常重要，你需要避免自己错过任何一个细节，尤其是与产品表现相关的内容。
5. **测试**：大多数需求都需要涉及测试，这是质量保障的重要环节。开发结束之后，研发会召集你和测试，提交他们的代码，进行效果展示。测试会根据你的需求提出问题，考核结果。提测会议结束之后，测试还会针对这个需求进行更加详细的测试。你不需要过分关注这一环节，它更多的是研发和测试之间的互动。常见的测试方法有单元测试（对当前改动的最小单元进行测试，例如某个新函数的输入输出是否符合详设文档描述）、集成测试（测试多个模块和系统之间的交互是否正常，包括新模块之间和新老模块之间）、性能测试（当前改动是否能够适应线上的访问和使用规模而不出现预料之外的问题）、回归测试（当前改动是否影响已有的功能，是否引入新的bug）等。一些简单的需求可能没有QA介入的提测和测试环节，但是测试工作不可能忽略，在这些QA不介入的需求当中，一般由RD通过单元测试和回归测试等方式进行自测。
> [“测试左移”](https://www.thoughtworks.com/zh-cn/insights/blog/testing/shift-left-testing)也是一种软件开发实践，它要求研发人员在研发的过程中，同步进行测试，以减少代码缺陷和返工造成的资源浪费。
6. **验证**：你需要在预上线环境验证你的需求是否已经达成，在这个环节你需要争取验证到每一个细节，有任何不清楚的点，都需要给研发和测试指出。他们会向你解释，如果有任何不能接受的要点，你需要要求他们修改，直到满足你的需求为止。
7. **上线**：你的需求会正式上线，进入生产环境，你的用户能够真正看到和使用这些新功能。
8. **验收**：在生产环境，你需要模拟你的用户，再次验证你的需求已经完成。在这个环节，你的重点是体验你的需求细节，找到也许可以改进的点，作为后续升级的开始。当然，也有小概率线上环境会出现预期之外的问题或bug，这时候你需要要求研发回滚版本，避免引起不必要的用户投诉，甚至公司的财产、收益损失。
另外，如果你正在负责的产品涉及到比较复杂系统的用户交互界面，上图并没有介绍与UI/UE之间的合作流程。但总体来说，你和UI/UE的协作流程，与和研发之间的合作也是类似的——你提出需求，UI/UE设计，然后你验收，交给前端实现，然后UI/UE再验证。只不过这个流程可以并不严格遵循迭代的时间，这具体取决于和你合作的UI/UE团队的工作流程和规范，也许需要你自己摸索。
## 1.3. 迭代中的需求
关于产品经理，我们常常听到的词语就是“需求”，需求是客户或者用户的想法，他们在使用你的产品的过程中，可能遇到问题，可能提出期许；可能强烈地向你反映，也可能默默忍受一些不便。你作为产品经理，应该了解到他们的需要，找到方法满足他们，从而让客户或用户更爱用你的产品——这是你的主要工作目标。本小节将大致讲述需求的生命历程，但是必须注意，行业面对的一切情况都是快速变化的，你不可能找到一个教程能够保证让你顺利地应付一切需求和需求相关的工作。正如敏捷宣言所说：
> 响应变化 **高于** 遵循计划
一般来说，需求相关的工作总是在迭代节奏当中，例如，你可能要在上次迭代进行过程中，做好需求的收集和评估，准备好需求方案；在本次迭代初期，发起需求评审；在下次迭代开始，验证需求的效果，然后投入到新一轮的需求工作当中去。
我们可以简单地把需求的生命周期抽象为：收集需求、评估需求（前两个环节也可以并称为“需求调研”）、产出方案、验证效果和持续迭代。
### 1.3.1 收集需求
收集需求是需求生命周期的开始，也是产品每次升级的开端。PM从收集到的需求出发，分析出软件下一步的更新方向和具体的解决方案。一般来说，收集需求有两种典型场景，“毫无准备的”或“目的明确的”。
“毫无准备的收集需求”是指，在没有任何倾向和前置问题的情况下，广泛地收集需求，这一般发生在产品或某个独立功能从零开始的最早阶段，在这个阶段，你对于任何想法都保持开放态度，想要知道用户或客户们的所有需求，希望从中发现有价值的部分，转化成一个可行的软件（或者你当前软件的新功能模块），交付给他们使用，解决他们的问题。头脑风暴是此时常用的方法：
- **头脑风暴**：和你的用户们（即使你的产品还没有任何进展，你也应该有某个产品的大致方向，例如“我想做一款服务老人的软件”“我想做一款服务来华旅游的外国人的软件”等等，这些方向都足以帮助你找到你的用户）坐在一起，聊聊他们的想法、遇到的问题、想要的功能等等，任何话题都可能成为头脑风暴的一部分。理想的头脑风暴，应该邀请足够多样的目标用户，例如“我想做一款服务老人的软件”这个点子，就应该邀请不同性别、不同收入、不同城市等背景都不相同的老人，这样你才能尽可能全面地了解信息。头脑风暴不是空想，你需要主导这场会议达成它的目的——收集需求并初步了解它们的价值和急迫程度。冷场时，你可能需要抛出新的问题；发言逐渐偏离轨道时，你可能需要及时纠正。会议结束之后，你应该获得一份列表，上面记录着你认为有价值的需求和想法，并标记你纵观整场讨论，主观判断的优先级排序——在这一堆需求和想法中，用户们可能觉得哪些比另外的更重要。头脑风暴最好只有PM参加，在这个阶段尽量不要引入技术视角，避免他们的专业观点影响用户们的原始和自由表达。
“毫无准备的收集需求”在工作中并不常见，更多的还是“目的明确的收集需求”。这是指，产品项目在正常运行中，某些阶段上你已经为产品拟定了明确的发展路径，例如下一步需要新增支持某个新场景，完善某些旧问题等等。在这种情况下，你已经预设了一个明确的目的，你需要收集的是用户或潜在用户对这个目的的反应。以下列举了几种此类收集需求的方式：
- **问卷调查**：问卷调查是一种非常常见的调查方式，它通过直接设问，来获取用户或潜在用户的反馈。在软件当中发放问卷是非常便利的，如果你的产品有专门的通知工具，例如站内信、客服窗口等，可以利用它们给你的用户发放问卷；或者你也可以通过前端的简单组件，例如横幅、弹窗等方式向用户直接发放问卷链接，收集他们的反馈。但是此类问卷的方式也有问题，例如频繁的弹窗或问卷引流破坏用户体验、不明显的问卷导致回收数过少、过量的问题或激励导致回答失真等等。你应该仔细考量问卷的内容和吸引用户填写的方式。
- **用户访谈**：用户访谈就是通过对谈等方式，直接获得用户或潜在用户的反馈。这种方式更直接，你能够通过文字之外的表达来获得更多信息（例如表情、语气、动作等），当然收集的内容则不一定全面（这取决于你有多少的时间和精力，以及能招募到多少人愿意配合你的访谈）。相较于问卷调查，用户访谈更为灵活，你可以针对上一个问题中感兴趣的回答更深入地交流沟通，也可以根据用户的喜好和反应来安排后续问题的顺序。
在收集需求时，最好不要直接给用户方案，例如“如果我提供某某样的功能，是否能解决你的某某问题”这样的问题是差的，因为它切断了用户的思路，让你距离用户的切实需求更远。努力做一个合格的聆听者，在这个阶段不要让你的专业知识和产品经验影响用户的自由表达。让用户告诉你应该做什么，而不是告诉用户他应该要什么。
> 尽管我们经常听到“用户想要跑得更快的马，但从不知道他们可以开上汽车”这样的故事，但这并不代表你应该在收集需求的阶段就告诉用户“如果我有一台汽车，如何？”——究竟是提供一匹跑得更快的马还是提供一台汽车，这是在之后的环节中你的工作内容。在这个阶段，如果你听到用户想要更快的马，那么你收集到的正确信息应该是“用户想要更快”，至于是马还是汽车，还是自行车，还是高铁，还是飞机，还是一台超炫酷的核动力机甲？这些问题应该留给后续的环节完成，因为你不可能在这个阶段就要问用户这样的问题：“请问你是选择一匹马，一台汽车，一台自行车，一列高铁，一架飞机，还是一台超炫酷的核动力机甲？”
> 当然，这并不意味着你应该全盘接受用户的要求。当他们要求一匹更快的马的时候，尝试问他们“你需要在什么时候骑马？是从家到公司，还是从北京到天津，还是从中国到美国，还是从地球到月球？”“你觉得这匹新的马需要多快才可以，它需要装货物吗，装什么样的货物？”这样的问题，这有助于让你了解用户的需求场景，让你找到解决用户真实问题的入口——如果用户想要从地球到月球，那么一台汽车跑得再快也无济于事，你恐怕需要考虑一台炫酷的核动力机甲了。
另外，需求很多时候也会直接来自于你的产品运营同事。他们的工作就是接触用户，用户有很多的问题或需求会直接向他们反馈。他们会整理之后再向你反馈。在收集需求和评估需求的阶段，多和他们合作和沟通，了解用户的反馈。
需求的范围有大小，我们一般按照Epic、Feature和Story三个层级来区分需求的大小，Epic可能是一个重大的项目，Feature可能是一个相对独立的功能模块，Story则是预期能够在一两个迭代中完成开发的升级或改动。你收集到的需求也有大有小，注意在设计方案时区分需求的大小，不论你想要实现什么大小的需求，最终都需要拆分到Story的粒度来推进。
### 1.3.2 评估需求
在上一环节之后，你获得了一个记录着大量需求的列表，接下来，你需要决定哪些需求要实现，哪些不要实现，哪些应该先做，哪些应该后做。这个过程就是需求评估。需求评估主要评估需求的两个方面：可行性（合理性）和优先级。前者更多决定了需求是否要做，后者决定了需求开发的先后顺序。
- **可行性**：指的是需求是否可以实现。实际工作中很少遇到绝对无法实现的需求，因为提出需求的人总是知道运用现代技术，软件开发团队大概能做什么而不能做什么，就算是“跟随壁纸动态改变颜色的手机壳”这样的需求，也并不是完全无法实现——如果你有无限的成本的话。所以在评估可行性时，很多时候是在评估可行性的高低，抑或合理性。合理性问题并不总是像“跟随壁纸动态改变颜色的手机壳是不合理的”那样显然，很多时候你都需要结合产品的整体架构、基本目标，甚至市场规律等宏观视角来考虑合理性的问题。有的需求像是合理且可行的，但是有可能与产品的总体目标相悖、与其他用户的利益冲突等等，仍然会被认为不合理。你需要结合很多背景知识来考察需求的合理性问题。
- **优先级**：在上面一个步骤之后，你已经排除了一些不合理的需求。剩下的需求，你的团队大概率不能够同时投入人力来解决。因此，你需要把你认为合理的需求进行优先级排序，告诉自己和团队先做哪些后做哪些。对需求进行优先级排序需要综合考虑多方面因素，包括但不限于以下内容。最好不要根据任何一个单独的因素作出判断，尽量考虑得更全面，因为优先级的排序会直接影响产品的整体发展走向：
  - **用户的迫切程度**：在收集需求时，哪些需求是用户或运营同事们一再、强烈反馈的，这证明用户们非常需要你实现它；
  - **成本收益考量**：有些需求如果实现，需要消耗大量成本，例如复杂的业务逻辑或大量的体验升级需要消耗更多的研发工时，过大的数据量需要消耗额外的存储空间，大模型调用需要消耗昂贵的算力等等。而这些需求如果实现，是否能够获得超越这些成本的收益？毕竟团队的资源有限；
  - **依赖与耦合关系**：很多时候需求并不是独立的，需求之间往往存在相互关系，这些关系在客观意义上直接影响着优先级的排序，详见 1.4.2. 依赖和耦合。
对优先级的排序，有很多方式。对于PM来说，可以采用经典的四象限区分：重要且紧急、重要但不紧急、不重要但紧急、不重要且不紧急。这种区分方式能够快速划分需求的优先级类型，帮助在初期整理需求时，理解手上所有需求的优先级全景。对于团队来说，这种区分方式可能还不够指导工作，有的团队会使用P级（priority）来标记需求的优先级，其中最优先的是P0，往后是P1、P2……以此类推。P级能够很直观地排列需求的优先级，告诉研发团队哪些需要优先支持哪些需要后续支持。但当需求数量膨胀的时候，P级之间的差异越往后就会越失真——P0和P1之间的差异，会比P99与P100之间的差异大得多得多。
### 1.3.3 产出方案
经过上面步骤之后，你现在已经明确知道要实现哪些需求。要实现需求，产品经理就必须要设计方案。方案就是你对需求和需求实现方式的描述。你如何向研发描述你的方案，直接决定着开发的速度和质量，也很大程度影响到产品的使用体验和价值。一个完整的方案可以包括但不限于以下几点：
1. **需求背景**：需求来自于哪，为什么要实现这个需求，和之前做的需求之间的关系是什么，等等。总体介绍你对这个需求的认知，这个部分的内容来自前两个环节。内容尽量简洁，尽快让研发和测试明确这个需求之所以要做的原因。
2. **需求概述**：以列表或者其他形式快速概括本次需求方案涉及的开发内容，要新增什么，删除什么，修改什么（In Scope）。对于复杂的，或者与其他需求容易混淆、耦合、依赖的需求，也说明不要开发什么（Out of Scope）。
3. **需求收益（可选）**：在你的需求评估过程完成后，你预计这个需求完成之后能带来什么收益。最好是可量化的指标，例如预计给平台带来多少收入、带来多少用户量等等；当然也可以是描述性的，例如提升产品可用性、提升交互友好程度等。对需求收益的描述能够帮助开发团队更好地理解他们接下来工作的意义，建立对整个产品开发路线图的全景概念。
4. **需求详述**：最重要的部分，在这个部分，你需要彻底且清晰地描述你想要做什么，以及怎么做。这里唯一的标准就是，你要知道你自己在说什么，并且争取做到让所有人看完之后都知道你在说什么。常见的工具有原型图、列表、流程图、伪代码等。厂内的知识库工具原生支持大部分[Markdown](https://markdown.com.cn/)语法，你也应该用起来。
5. **推进节奏（可选）**：你期望的需求开发路线图，以及开发完成之后，如果有小流量验证环节，你期望维持多久，以什么为标准推全等等。
6. **附带的数据需求（可选）**：为了验证这个需求的效果，你需要在业务流程的哪些环节，为哪些数据打上标记，制作一份怎样的报表等。
注意，方案不是你一个人的工作，在撰写方案的过程中，你也可以征求研发的意见，例如什么样的解决方式在技术上更合理、成本更低；你也可以征求运营的意见，客户也许更喜欢这样而不喜欢那样。这些沟通尽量在需求评审之前完成。
- 和研发的沟通，经常聚焦于研发成本的讨论。开发、实现一个需求涉及很多成本，其中需要PM关注的主要是人力成本。研发团队一般靠人天（pd，person day）来衡量一个需求的人力成本消耗，即实现这个需求需要几人工作几天。一个需求越复杂，就需要消耗越多的人天。此外研发团队之间的交接、团队中新人加入、老人退出、需求变更等等，都会导致人力成本的额外消耗。如果你正在准备一个庞大且复杂的需求，你最好和研发提前确定成本的高低，如果成本太高，可能导致研发人力的大量消耗，从而导致后面的需求和项目整体无法顺利推进；消耗成本高的需求，在发现问题时返工也会消耗更多的资源和成本。因此，如果研发认为需求成本较高，尝试寻找替代方案（例如某些庞杂的业务逻辑是否可以被剪枝，复杂的交互动效能否简化等），或者将它拆分为多个小的Story来推进，以便灵活应对变化和问题。
- 和运营的沟通，经常聚焦于方案选择的讨论。实现一个需求可以有多种不同的方案，PM和研发或许都有各自的倾向，从PM和研发的视角来看也许都能够实现用户需求的方案，在运营视角则不一定。PM和研发视角容易丢失需求的细节和场景的区分，为了节省研发成本、达成全局最优，他们更希望采取最普适的、最简单的方案来支持最多的需求场景。从这种思路出发，PM和研发可能会放弃支持一些他们认为无关痛痒的需求细节和边缘场景。但是从运营视角出发则不尽然，他们可能会从日常与用户的接触和互动中，总结出某些细节需求的重要性，在PM和研发看来无关痛痒的细节，可能恰恰是用户所需要的。所以当你想要裁剪你的方案、考虑减少方案支持的场景时，除了和研发达成一致，你有必要和运营积极沟通这些细节，保证方案能够满足用户的基本要求。
### 1.3.4 验证效果
在评估需求和产出方案的阶段，你对实现当前需求将会带来的收益做出了预估。你有必要验证这个预估，即实现需求之后，预估的收益是否如同预期一般产生。这就是对需求效果的验证。验证效果有助于评估需求的实际价值，为产品的长期迭代升级总结经验、发现方向、提供指导。
不同的需求有不同的收益指向，对收益的评估也有不同的角度。有的需求明确指向用户数、收入、GMV等业务指标的提升，例如为会员用户提供更多进阶功能、为某些用户提供使用激励等，评估此类需求可能需要统计业务指标，计算它们的变化情况；有的需求则对业务指标没有那么直接的影响，而是侧面提升产品体验，例如优化前端页面动效、重新梳理功能导航架构等，评估此类需求可能需要调查用户满意度等。
如果需求达到了预期的效果，那证明这个方向的需求可能是行之有效的，可能是用户所需要的，或者对业务有促进效果的，在后续的产品迭代中，需要更加重视此类需求。如果需求没有达到预期效果，则更需要着重分析原因，究竟是需求本身没有调研时认为的、对用户的价值和吸引力，还是方案对需求场景裁剪得太多，还是产品推广的过程和目标用户出现了偏差，还是其他的原因——对没有达到预期的需求的原因进行分析，有助于在后续迭代的过程中，规避已发生过的问题，减少开发资源和产品推广资源的浪费，也能让产品更贴合用户的实际需要，促进实际业务的改善和提升。
### 1.3.5 持续迭代
每一个需求实现之后，你都能完成对它们的评估，总结成功的经验或者失败的教训，提出新的需求对产品进行优化或者提升——又或者只是简单地解决被第一版替代方案所裁剪的细分需求场景。总而言之，与需求相关的工作是一项循环往复的工作，你通过一项又一项的需求慢慢搭建一个完整的软件，并且持续优化它的效果，达成用户的期待，为用户持续提供使用软件的价值。
## 1.4 CI/CD与交付规范
CI/CD即持续集成（Continuously Intergration）与持续部署（Continuously Deployment）或持续交付（Continuously Delivery）。这是一种软件开发的工程实践，指的是开发团队的每一个人，都能够在软件开发和交付过程中持续地提交他们对代码的修改，并且借助持续交付和集成工具，自动化地部署他们提交的代码修改，始终保持软件处于最新状态。
> 如果你玩网络游戏，你一定对更新和热补丁不陌生，这就是广义上CI/CD的一种体现。开发商在持续的迭代中为你准备好一个完整的更新包或者补丁，你可以短时间内安装更新完成。也许只要半小时，你就能开始体验全新的内容，但其背后，可能是一整个团队为期数月甚至数年的努力工作。
这其中涉及到的重要工具有：Git，Jenkins等。作为产品经理，我们不需要知道其中的细节。但是与之相关，有一些重要的概念和规范仍然需要掌握。本小节将尝试解释它们，这些解释可能并不严谨，但是在工作中够用了。
### 1.4.1 环境
如果你是负责产品的一部分，已经有不少用户在使用你的软件了；如果你是全权负责某个产品从无到有的过程，在你发布第一个版本之后，也会有不少用户使用你的软件（不论是通过web访问还是通过客户端访问）。如果你要对其进行修改和优化，你就不能直接在他们正在使用的软件上直接进行，因为这会破坏他们使用体验的连续性，更不用说这个修改的过程中可能的错误、bug甚至恶性事故了。
最好的方式是有一个在功能上和你用户看到的软件一样的复制体，你在这个复制体上先进行修改，验证你的设计无误之后，再按照一模一样的修改方式修改你用户正在使用的版本，这样就可以最大程度上保证用户体验不受损害。在软件开发中，这个复制体就是一个“环境”，你的用户正在使用的，我们叫它“线上环境”或者“生产环境”；研发们着手修改的那个草稿，我们叫它“开发环境”或者“线下环境”。除此之外可能还有“预上线环境”，这是一个草稿和线上环境的中间态，往往是上线之前的最后一个验证环境。环境之间是相互隔离的，意味着任何一个环境的任何改动，都不会影响其他环境的表现。除非研发们使用CI/CD工具部署他们的最终修改，我们叫做“发布”或者“推”，例如从开发环境发布到预上线环境，再从预上线环境发布到生产环境——在开头的例子中，开发商向你推送更新包，就是一个发布到线上的过程。
### 1.4.2 依赖和耦合
依赖和耦合，是两个很相似的概念，也经常被混淆。一般来说，混淆它们**没什么大不了**。以下是对它们的解释。
1. **依赖**：依赖一般指的是两个需求之间的关系，如果你要实现需求A，就必须先实现需求B；或者你要实现需求A的一部分，就必须先实现需求B的一部分——或者类似的种种关系，我们称之为A依赖B。在庞大的项目中，依赖关系通常十分复杂，它会影响你对需求优先级的安排，以及研发在实现需求时采取的具体方案。所以你在撰写需求方案时，就应该尽量提前发现这种关系，以避免出现项目进度的卡顿。如果你非常想要实现需求B，那么你就应该先推动需求A，而不是在慌乱的时候催促研发们“赶紧实现B”，没人能做到这一点，除非你是软件工程之神。
2. **耦合**：耦合通常指的是已经实现的功能模块之间的关系，例如功能A调用了功能B，或者使用了功能B的一部分。如果你的需求涉及到这样的一组功能，或者这样一组功能中的一部分，那么你就应该通盘考虑这一组的所有功能，是否会受到你本次需求（不论是改动，还是新增，还是删除）的影响。如果会，影响又是什么，如何解决。
综上，依赖和耦合通常成群结队出现，你在梳理需求和撰写方案时必须注意，做好准备动作。你对于依赖和耦合所做的准备，都要体现到你的需求方案当中，相信团队成员们都会感谢你的这份付出。
### 1.4.3 故事卡
故事卡（story）同样也是一个敏捷的概念，它指的是对需求的描述和任务的拆分方式。故事卡的规范，要求我们将所有任务拆解至“合适”的范围（scope），既不能过大，也不能过小，以不产生依赖或最小程度依赖，能够解决用户实际需求，且预期能够在迭代内完成为主要标准。
我认为这个概念能够在某种程度上帮助我们撰写需求方案，识别依赖关系，拆分具体任务。
在这里，故事卡具有敏捷工程中的一些功能，例如交付时间管理、人力分配等。我们不需要过分关注，但是需要知道的是，一个需求方案需要对应一个故事卡，研发团队和测试团队，需要这些故事卡来标记和追踪他们的工作。关于故事卡的工作，你需要在icafe平台上完成。
### 1.4.4 技术债
技术债或者技术债务（technical debt），又称设计负债（design debt）或代码负债（code debt）。它是指研发人员为了加速软件的开发和上线，在技术设计和代码逻辑上采取了短期内能加速开发的变通、替代或妥协方案，但留下了可能影响后续长期开发进度、质量或效率的潜在问题。如果一个项目对上线时间要求严格，那么技术债务就难以避免，因为研发们将没有足够的时间来进行详细的技术方案设计，或者没有足够的时间来选择完成一项最优方案的开发。
技术债务的比喻十分恰当，因为它有借有还。如果你在某个阶段选择了负债——为了追赶工期，让研发们选择了替代方案，那么你就一定会在后续的某个阶段选择还贷——为了一个新需求，必须留出额外的时间来解决之前留下的技术债务问题。
### 1.4.5 小流量
[墨菲定律](https://zh.wikipedia.org/wiki/%E6%91%A9%E8%8F%B2%E5%AE%9A%E7%90%86)告诉我们，凡是有可能发生的事故，就一定会发生。如果你的产品涉及到较大的用户群体，或者比较重要的公司收入，那么你引起事故的风险就不容小觑。火苗最好是在还小的时候扑灭，以免越烧越旺。
小流量就是一个保证火苗可控的流程。研发可以引入一个白名单，只有加入这个白名单的用户才能够看到和使用你的新功能。上线后的一段时间内，你可以控制这个名单的规模，从少到多，并且你密切关注用户反馈，研发关注服务压力和线上bug。在经过一段时间、一批用户的验证无误后，研发再将这个名单移除，让所有人都可以使用。这个过程就是小流量保证风险可控的过程。在这个过程中，任何时候你觉得问题已经过大，你都可以把白名单清空，保证功能无人可用，然后再着手改进你的设计，这样就可以避免更大的事故了。
如果你要为你的需求适用小流量，你需要在方案中明确。
### 1.4.6 Case Study
如果开发过程中不幸真的发生了问题，你和你的团队最好针对这项问题进行反思，梳理问题引发的过程，找到问题发生的根因，优化团队的工作和合作流程，避免类似问题再次发生，这个过程就是Case Study. 问题有大有小，并不是所有问题都需要study，一般决定问题是否需要study的因素有：问题的影响规模（用户流失、经济损失、重大宕机等等）、问题的发生次数和频率（小问题，但是多次发生）、问题本身的价值（偶尔发现的程序或流程缺陷，如果能够纠正将规避严重问题）等等。
开发团队中的任何人都有权利召集case study，case study的负责人一般是发现问题的人或对问题产生具有直接关系的人。例如PM在线上验收过程中发现某处业务逻辑存在重大问题，或者某个研发在开发过程中引入了某个隐含的问题被QA发现等等。Case Study的负责人有义务调查清楚问题产生的原因，梳理一份尽量详尽的文档，在会议上对每个团队成员讲解问题的表征、产生的原因、造成的影响，并且提出自己切实的解决方案，以保证团队的开发流程或规范得到优化，在之后的工作中避免类似问题再次发生。在会议上，团队成员们都应该积极发表对于优化方案的看法，尽量找到最优的方案去提升后续开发和团队合作的质量。
需要特别注意的是，Case Study的目的不是定责，不是找到“罪犯”，更不是公开批斗大会，其目的应该聚焦在学习、提升和优化上，应该关注如何从错误和问题中吸取教训。如果某个问题严重到需要定责，那应该是公司内部审计、HRBP、合规等职能部门的工作。整理问题产生的过程和原因时，注意不要将其简单归咎于某个个人，因为如果真的由某个个人即可引起问题，那么团队的流程一定存在漏洞——为什么没有人核实他的权限、检查他的工作、帮助他发现问题？

---

# 2. 数据与工具
作为产品经理，你的工作很难不和数据打交道。不论是收益预估，还是效果测算，你都需要看到数据，用数据说话，用数据证明你的观点。
本节将会尝试解释一些和数据相关的**基本**原理和概念，帮助你形成基本的认知；同时也会介绍一些**基础**的工具和使用方法，帮助你快速开始工作，并且在遇到难题的时候不至于慌乱。
![数据表模型图](sources/table_model.jpg)
## 2.1 数据的基本概念
在这一小节中，我们将尝试解释数据库、数据表的基本概念，理解数据是如何描述客观世界的。在这一小节里，我将通过一个简单的例子来说明。
> 假设我们正在运营一个简单的家电销售公司，你只有一个小门店。业务很简单，主要包括：进货、仓储和销售。你的门店里只有你一个人全权负责这些事情。
### 2.1.1 数据库与数据表
数据库（database），是存放数据表（table）的库房。我们工作中接触到的数据库，绝大多数情况下是关系型数据库。关系型数据库存放的数据表，是由严格的关系所组织起来的。
关系型数据库的数据表由行（记录）和列（字段）组成。通常来说，一条记录就代表一个实体（entity），而记录中的每一列，代表这个实体的一个属性（attribute），每一行记录都是在描述实体的属性。最佳实践是一张表只用于描述同一种实体，这样我们可以通过共同的字段描述它们的属性。
> 结合上面的例子，我们可以很快发现，定义数据表首先需要找到“实体”，即你需要描述的对象。在这个家店销售公司的例子中，你可能需要描述的对象有：产品、进货订单、销售订单、顾客或者潜在顾客等。
> 找到实体之后，你需要结合你的业务来定义每种实体的属性。例如你要描述产品，你可能需要描述产品的编号、名称、类型、颜色、适用电压范围等等和销售业务有关的属性。其他的无关属性，你可能不需要关注，例如“我是否喜欢它”就不是一个值得在表中描述的属性。
> 如果你接触过C++，Python等面向对象的编程语言和程序设计理念，你会发现这个过程类似于定义类的过程。
一个数据库系统，最重要功能是增查改删（CRUD，Create, Read, Update, Delete），而对于产品经理来说，99.9%的工作只与查（Read）相关，我们在后面会谈到。
### 2.1.2 主键
表通常具有一个主键（primary key），这是每条记录的唯一且不重复的标识。当然表也可以没有主键，但是有一个会更好，这样便于你查找和定位数据。
> 假设你要记录顾客的信息，你最好给每个顾客分配一个不重复的编号（当然也可以用身份证号，假设你能获取的话），而不是用名字来标记他们。因为随着顾客数量的增长，你很难保证没有重名的人。
当你描述的实体特殊时，你还会接触到业务主键和物理主键的概念。
- 业务主键，指的是在业务意义上保证实体唯一的标识，它在业务中有实际意义，但在数据库中不保证唯一性质。
- 物理主键，指的是在数据库中保证记录唯一的标识，它在业务中没有实际意义（最好保证没有实际意义，避免设计表结构时造成可读性的混乱）。
以下是一个简单的例子，GUID就是最常见的物理主键（自增编号），订单号就是其中的业务主键。
> 假设你有一个订单表，它有两个重要的字段：订单号、状态（包含新开、已交定金、产品运输中、已完成、已取消这些值）。
> 当你新开一单的时候，这个表就应该新增一条记录，此时你获得了一个新的订单号（假设是DD001），它在业务事实中指代一个唯一的、真实的订单。
> 当这个订单的状态变更（例如顾客交完定金）时，你有两个选择，要么直接在上面这条记录上更改，把新开改为已交定金；要么新增一条记录，订单号同样是DD001，但是状态是已交定金。
> 这取决于你的需要，一般来说，后者是更好的实践，因为它能够记录这个订单所有的变化历史。这几乎是所有业务都必须具备的，万一客户有异议和纠纷，你就可以追溯订单的完整变化历史。
> 当然，仅有订单号和状态这两个字段肯定还是不够的，我们至少还需要一个更新时间，记录订单每次都是在什么时候更新的。还需要一个物理主键，比如GUID，它从表的第一条记录开始自增，从而保证每条记录的键值都不同。
在上面例子的表中，你描述的实体其实已经不是“订单”本身，而是“订单的修改”了。像这样的抽象，在系统设计中往往司空见惯。
### 2.1.3 指标与维度
上面说到的实体-属性结构是一个利用数据库表描述客观世界的重要模型。在分析业务时，我们需要用到指标-维度模型，你也可以认为指标是一种实体而维度是指标的一种属性。只不过指标并不像家电产品、顾客那样在客观世界中实有所指，它已经是一种对客观世界发生的事实的总结了。
- 指标（indicator），是用于描述业务的一个或一组数字，它能够衡量业务的进展或状态，评估业务的表现。在销售业务场景中，常见的指标有：销售额、成本、收益、客户人数等。
- 维度（dimension），是计算和观察指标的视角，是对指标的切割或聚合，指标在不同的维度上，可以按照不同的方式汇总、拆分，或者做其他复杂的数学计算。

> 上图是一个典型的用于说明维度意义的示意。假设整个立方体是全年、全世界、全部产品的销售额，我们既可以按照时间（分季度），也可以按照区域（分销售大区），还可以按照产品线（分产品）去拆分、计算、观察和分析销售额。在这个例子中，销售额就是指标，时间、区域和产品线就是维度，而Q1，Q2，Q3，Q4四个值就是时间维度的维度值，意味着销售额在时间这根轴上能取哪些值（能被如何切分）。
从上图中，我们可以形成对维度-指标模型的大致概念。不过在实际场景中，这个模型会更加抽象，超过3个维度的模型，我们就已经无法通过三维图像来表示了。
我们还可以发现：
- 第一，不同的维度之间可以叠加（取交集，例如你想要知道Q1的、亚洲大区的、TV销售额，即红色部分），也可以合并（取并集，例如你想要知道全年的、亚洲大区的所有产品的销售额，即黄色部分）。
- 第二，同一个维度之中，可以细分（下钻，例如你想要知道1月份的销售额，就是在Q1之下继续下钻），也可以聚合（上卷，例如你想要知道全年的销售额，那就是把Q1～Q4的全部加起来）
观察这个立方体，我们可以发现，在设计指标的维度时，我们应该保证每个维度的拆分都是合理的。假设你想要在产品线中增加一个维度值，名为“白色”，那就会产生混乱，因为不论是笔记本电脑、手机、电视还是平板电脑，都可以有白色的产品，我们就无法在产品线维度上正确下钻和聚合数据了。
> 如果你确实需要根据颜色来拆分分析销售额，正确的做法是增加一个名为“颜色”的维度，在这个维度轴上区分产品的颜色。这个维度中，维度值应该是你产品的所有可能的颜色。
### 2.1.4 oltp、olap与数据仓库
oltp是“联机事务处理”（online transaction processing）的缩写，是指通过数据系统、数据表等功能，实现联机、实时处理业务事务的过程，例如输入、保存订单，传输订单到工厂，查询和输出客户信息等等，常见于对时效性要求高的业务事实过程，主要是通过数据库表，为业务实时提供服务的能力。
olap是“联机分析处理”（online analytical processing）的缩写，是指通过数据库系统实现多维数据分析的过程。olap是广义上的“商业智能”（BI，Business Intelligence）的一部分，它能够很好地帮助商业数据分析师分析业务的进展、预估业务的未来表现、评估业务的收益与成本等等。
olap往往和数据仓库（data warehouse）一起出现，这两个概念也很类似，我们很大程度上可以认为这两个概念描述的是一套系统。数据仓库是一套由计算引擎、文件系统和数据任务调度器组成的数据收集、清洗、计算加工和统一输出的系统。它往往是实现大型数据分析需求的基础。它从各个业务系统中收集原始数据，经过清洗、加工、计算等处理之后输出给各种数据分析工具，例如可视化工具（sugar BI）、数据查询工具（TDA、datapilot）。有时候也会反过来再输出给各个业务系统，用于统一一些流程中的公共数据，避免不同业务之间出现数据冲突，也避免业务系统之间直接进行数据交互造成的复杂和混乱。
数据从收集，到清洗，再到最终输出，需要经过很多环节，数据仓库通过分层架构来实现整个流程，通过任务调度器来管理各环节的计算进度，处理任务依赖，检查任务进度，自动触发重试等等。我们不需要了解这些概念，对工作毫无帮助。比较重要的有以下几点：
1. 表权限：如上所述，数据仓库可能涵盖了整个公司所有的业务，因此它会提供巨大量级的数据表。有的表和你的工作无关，有的表数据敏感（具有公民隐私信息等），有的表已经过时，有的表已被废弃。所以对于你来说，你只需要拿到必要的表的查询权限即可（[什么是最低权限原则？](https://www.cloudflare-cn.com/learning/access-management/principle-of-least-privilege/ )）。你需要用到的数据表权限，在这里统一管理：数据管理平台
2. 分区（分片、切片）：分区是一种数据库管理技术，它用于将大表拆分成小的部分，以此提升表和数据的可读性和可扩展性，也可以提升查询性能。分区的方式有很多种，你能接触到的表，绝大多数会按照日期分区，也就是说，一张大表会按照数据写入的日期，分为多个小表。在查询时，你需要告诉系统，你想要查询的是哪天写入的数据。时间分区也有两种类型：全量分区与增量分区。你能接触到的表，大多数情况下都是全量分区表，在查询时需要注意分区的选择和指定。
  1. 全量分区，指的是每次写入完成后，都复制一次当前全量的表数据保存到当前分区，换句话说，在不清理数据的情况下，你可以在2024年1月1日之后的每一个分区中，都查询到这天写入的某条数据。
  2. 增量分区，指的是每个分区仅保存当天新增的数据记录。这种分区方式使用起来更加复杂，尤其是涉及到同一业务主键的记录频繁修改时。在通常情况下，想要查询一个时间跨度很长的业务主键的最新记录，你需要用到窗口函数。
## 2. 常用的数据工具
使用工具，是让数据说话的必要步骤。
### 2.1.1 SQL
SQL是结构化查询语言（Structured Query Language）的缩写，它适用于数据库的CRUD过程。ISO组织对SQL的读音规定是这三个拉丁字母在英语中的读音，即/ˈɛs kjuː ˈɛl/，wiki的说法是/ˈsiːkwəl/，实际工作中也有很多人读成circle的发音，即/ˈsɜɹkəl/。读成什么样不重要，你只要知道大家在说这个东西就可以了。
顾名思义，SQL能帮助你结构化地查询数据，“结构化”一词强调了数据的关系性和这门语言的组织方式，SQL本身是成体系成结构的，并且在字段-记录组成的结构化的表当中查询，并且输出成结构的结果。
我本想写一个比较完整的SQL入门，但是厂内已经有非常完善的入门教程了，请参考TDA（原一脉）团队的入门指南：3、TDA-SQL查询使用说明。值得一提的是，你在厂内写SQL的任务，99%将在这个平台上进行，所以不再赘述。**有这样完整的教程存在，任何同事对你说“我不会SQL”“我学不会SQL”的行为都是值得被痛恨和唾弃的。**
在此之外，你可能需要了解一下窗口函数（[PostgresSQL中文手册：窗口函数](http://www.postgres.cn/docs/9.3/tutorial-window.html)）和CTE（[PostgresSQL中文手册：WITH查询](http://www.postgres.cn/docs/9.3/queries-with.html)），但是这不必需，所以我也不在这里展开。
### 2.2.2 Excel
Excel是世界上最知名的办公套件MS Office提供的电子表格格式和标准。在Excel中我们可以非常直观地观察、管理和分析数据。Excel的内容太过于庞大，我不能做过多的介绍。但是在我的工作中，我认为Excel有三个非常重要且好用的功能，分别是：
1. VLOOKUP(查找值, 表范围, 列序数, \[可选：是否模糊匹配，默认为是\])：这个公式非常强大，可以实现类似于JOIN的操作，将其他地方的数据，通过公共列映射到当前范围中，便于把部分数据聚拢到一起进行观察、计算和分析。
> 假设现在我有一个表格，A列是不重复的user_id，B列是消费cost。现在我获得了一个新的数据集，并把它粘贴到了这个文件中，现在我的E列也是不重复的user_id，F列则是成本charge。现在我想要看看每个user_id的消费和成本。
> 你可能想到，把F列放到C列的位置，这样我们就得到了user_id, cost, charge的表结构。但是请注意，A列的user_id和E列的user_id这两个集合并不一定相等，即使相等，顺序也不一定一致，如果直接复制F列到C列的位置，数据极有可能是错误的。
> 这时候你就可以使用VLOOKUP公式，在C2单元格中输入：=VLOOKUP(A2, E:F, 2, FALSE)，确定，然后使用自动填充功能填充C列。
> VLOOKUP(A2, E:F, 2, FALSE)，代表在E:F的范围的第一列（也就是E列）中，查找A2的内容，并且是精确查找（这意味着只有完全一样的值才会被认为查找到，如果你选择模糊查找，则只要E列中包含A2的值，就会被认为是查找到），之后，将第2列（也就是F列）对应位置的值返回。
> 注意，不论是使用模糊查找还是精确查找，VLOOKUP永远只会返回自上而下第一个被查找到的位置的值。
2. TEXTJOIN(分隔符号, 是否忽略空单元格, 表范围)：这个公式可以将某些单元格中的内容，转化成一行文本，并且按照你要求的符号进行分隔。它可以用于写SQL的IN条件查询、用户ID加入白名单等等需要逗号分隔的文本场景，非常简洁快速。
> 假设现在你在A列有一列user_id，现在你要在一脉上查询这些user_id的消费。最快的方式是在WHERE条件中增加user_id in ()的条件，但是in ()条件的括号中只接受逗号分隔的文本或数字（当然还有子查询，但是这和我们要说的无关），这时候如果直接复制这一列单元格是无法实现的，因为单元格是回车分隔的。
> 你可以使用TEXTJOIN公式，在任意单元格中输入=TEXTJOIN(",", TRUE, A:A)，确定，然后你就会得到逗号分隔的一串user_id.
> TEXTJOIN(",", TRUE, A:A)，代表通过,分隔，组合A:A范围中的数据，并且忽略空单元格。如果你在第二个参数选择TRUE，Excel会把空值也添加进结果中。
> 注意，TEXTJOIN能生成的字符串长度是有限的（受制于单元格的限制），如果生成的字符串超过 32767 个字符，Excel会返回一个 #VALUE！ 错误。
3. 数据透视表：它可以在Excel中实现数据聚合，也就是聚合函数加上group by的功能，便于你在不同的维度上分析和计算数据。

---

# 3. 其他
我认为合格的产品经理应当具备这样的品质：真诚、自信、负责、求知。
你可能还感兴趣：
- [AWS亚马逊云从业者认证培训](https://aws.amazon.com/cn/training/learn-about/cloud-practitioner/)：了解云基础设施和分布式开发的基本知识
- [SCRUM指南中文版](https://scrumguides.org/docs/scrumguide/v2020/2020-Scrum-Guide-Chinese-Simplified.pdf)：了解敏捷的游戏规则
- [SCRUM中文网](https://www.scrum.cn/)
- Pandas：厂内大模型工具平台
> 西郊有密林 助君出重围
